###############################################################################
# SphAutSpec: Maple package for the spherical automorphic spectrum
# 
# Authors: Marcelo De Martino and Eric Opdam
# Reference: arXiv:2207.06773
# Repository: https://github.com/mgdemartino/SphAutSpec
# Version: v00, Feb 2026
#
# Conventions (following Bourbaki, Planches I-IX):
#   1. Let V and V' be the relevant vector spaces where the geometry takes place.
#   2. We input the 'dual root system' (coroot system): R' lives in V'.
#   3. Simple coroots and positive coroots live in V'.
#   4. Fundamental weights live in V.
#   5. The q-residual subspaces live in V.
#   6. Simple coroots form a basis of V'; fundamental weights form a basis of V.
###############################################################################

SphAutSpec := module()

description "Maple package for computing the spherical automorphic spectrum via the cascade algorithm (arXiv:2207.06773)";
option package;

#------------------------------------------------------------------------------
# EXPORTS - Data I/O
#------------------------------------------------------------------------------
export Read;

#------------------------------------------------------------------------------
# EXPORTS - Root Systems: Basic Structure
#------------------------------------------------------------------------------
export CartMatrix, FundWeight, JPoscoRoot, LieDual, MLieDual, PoscoRoot, SimpcoRoot, SinR;

#==============================================================================
# DATA I/O
#==============================================================================

Read := proc(f::string)
description "Allows to assign to a variable the contents of a file.";
        local ret;
        read f;
        ret := %;
        return ret;
end proc; # Read

#==============================================================================
# ROOT SYSTEMS: BASIC STRUCTURE
#==============================================================================

CartMatrix := proc(X::symbol,n::integer)::Matrix;
description "Compute the Cartan matrix for root system (X,n).";
        uses LinearAlgebra;
        local M, S, i, j, m;
        S := SimpcoRoot(X,n);
        M := Matrix();
        m := RowDimension(S);
        for i from 1 to m do
                for j from 1 to m do
                        M(i,j) := DotProduct(Row(S,i),2*Row(S,j)/(DotProduct(Row(S,j),Row(S,j))));
                od;
        od;
        return M;
end proc: # CartMatrix

FundWeight := proc(X::symbol,n::integer)::Matrix;
description "Returns a matrix whose rows are the fundamental weights.";
        uses LinearAlgebra;
        local W;
        if ( RowDimension(SimpcoRoot(X,n))=0 ) then
                return Matrix();
        else
                W := LinearAlgebra:-MatrixInverse(Transpose(CartMatrix(X,n))).MLieDual(SimpcoRoot(X,n));
        end if;
end proc: # FundWeight

JPoscoRoot := proc(J::list,Ca::Matrix)::Array; 
description "Returns the root subsystem of R' generated by J and how it embeds in R'. Ca is the Cartan matrix.";
        uses LinearAlgebra, ListTools;
        local S, N, n, U, i, R, l;
        S := PoscoRoot(SubMatrix(Ca,J,J)); 
        N := RowDimension(S);
        n := ColumnDimension(Ca);
        U := Array(1..N,1..n);
        for i from 1 to nops(J) do
                U[..,[J[i]]] := Column(S,i);
        od;
        U := convert(U,Matrix);
        R := PoscoRoot(Ca);
        l := SinR(U,R);
        return Array(1..1,1..2,{(1,1)=S,(1,2)=l});
end proc: #JPoscoRoot

LieDual := proc(v::Vector)::Vector;
description "Returns the Lie dual vector 2v/(v,v).";
        uses LinearAlgebra;
        local i, w, N;
        w := [];
        N := DotProduct(v,v);
        if ( Norm(v,1)=0 ) then
                return v;
        else
                for i from 1 to numelems(v) do
                        w := [op(w),(2*v[i])/N];
                od;
        end if;
        w := convert(w,Vector[row]);
        return w;
end proc: # LieDual

MLieDual := proc(Mv::Matrix)::Matrix;
description "Returns the Lie dual of each row of a matrix.";
        uses LinearAlgebra;
        local i, A;
        A := [];
        for i from 1 to RowDimension(Mv) do
                A := [op(A),convert(LieDual(Row(Mv,i)),list)];
        od;
        A := convert(A,Matrix);
        return A;
end proc: # MLieDual

PoscoRoot := proc(Ca::Matrix)::Matrix;
description "Compute all positive coroots from a Cartan matrix. Returns a matrix where each row is a positive coroot expressed in the basis of simple coroots.";
        uses LinearAlgebra, ListTools, FileTools;
        local r, h, i, x, j, p, q, R, s, n; 
        if ( RowDimension(Ca)=0 ) then 
                return Ca;
        end if;
        n := ColumnDimension(Ca);
        if ( n=6 or n=7 or n=8 ) then
                if ( Ca(1,3)=-1 and Determinant(Ca)<=3 ) then
                        s  := cat("DataBase-TypeE/PoscoRootE",n,".mpl");
                        if ( Exists(s) ) then
                                return Read(s);
                        end if;
                end if;
        end if;
        r := [seq(convert(IdentityMatrix(n)[i], list), i=1..n)];
        h := 1;
        i := 1;
        while ( i<=nops(r) ) do
                if ( add(x,x in r[i])=h ) then
                        for j from 1 to n do
                                p := 0;
                                while ( member(r[i]-(p+1)*r[j],r) ) do
                                        p := p+1;
                                od;
                                q := p-convert(r[i],Vector).Column(Ca,j);
                                if ( q>0 ) then
                                        r := [op(r),r[i]+r[j]];
                                        r := MakeUnique(r);
                                end if;
                        od;
                        i := i+1;
                else
                        h := h+1;
                end if;
        od;
        R := convert(r,Matrix);
end proc: # PoscoRoot

SimpcoRoot := proc(X::symbol,n::integer)::Matrix;
description "Return the simple coroots as an n-by-m matrix (rows are coroots in Euclidean coordinates). Supported types: A, B, C, D, E (n=6,7,8), F (n=4), G (n=2).";
        uses LinearAlgebra;
        local r, i, j;
        r := Matrix();
        if ( X<>A and X<>B and X<>C and X<>D and X<>E and X<>F and X<>G ) then
                return r;
        end if;
        if ( n=1 ) then
                return <1|-1>;
        end if;
        if ( n>1 ) then
                if ( X=A ) then
                for i from 1 to n do
                        for j from 1 to n+1 do
                                if ( j=i ) then
                                        r(i,j) := 1;
                                elif ( j=i+1 ) then
                                        r(i,j) := -1;
                                else
                                        r(i,j) := 0;
                                end if;
                        end do;
                end do;
                return r;
        end if;
        if ( X=B ) then
                return DeleteColumn(SimpcoRoot(A,n),n+1);
        end if;
        if ( X=C ) then
                return RowOperation(SimpcoRoot(B,n),n,2);
        end if;
        if ( X=D ) then
                return RowOperation(SimpcoRoot(C,n),[n,n-1],1);
        end if;
        if ( X=E ) then
                if ( n<6 ) or ( n>8 ) then
                        return r;
                elif ( n=8 ) then
                        return << 1/2|-1/2|-1/2|-1/2|-1/2|-1/2|-1/2 |1/2>;
                                <   1|   1|   0|   0|   0|   0|   0|   0>;
                                <  -1|   1|   0|   0|   0|   0|   0|   0>;
                                <   0|  -1|   1|   0|   0|   0|   0|   0>;
                                <   0|   0|  -1|   1|   0|   0|   0|   0>;
                                <   0|   0|   0|  -1|   1|   0|   0|   0>;
                                <   0|   0|   0|   0|  -1|   1|   0|   0>;
                                <   0|   0|   0|   0|   0|  -1|   1|   0>>
                elif ( n=7 ) then
                        return DeleteRow(SimpcoRoot(E,8),8);
                else
                        return DeleteRow(SimpcoRoot(E,7),7);
                end if;
        end if;
        if ( X=F ) then
                if ( n<>4 )  then
                        return r;
                end if;
                if ( n=4 ) then
                        return <<   0|   1|  -1|   0>;
                                <   0|   0|   1|  -1>;
                <   0|   0|   0|   1>;
                < 1/2|-1/2|-1/2|-1/2>>;
                end if;
        end if;
        if ( X=G ) then
                if ( n<>2 ) then
                        return r;
                end if;
                if ( n=2 ) then
                            return << 1|-1| 0>;
                                <-2| 1| 1>>;
                        end if;
                end if;
        end if;
end proc: # SimpcoRoot

SinR := proc(S::Matrix,R::Matrix)::set; 
description "Returns the set of row indices in R that match rows in S.";
        uses LinearAlgebra;
        local r, s, l, i, p, j;
        r := RowDimension(R);
        s := RowDimension(S);
        if ( ColumnDimension(S)<>ColumnDimension(R) ) then
                return {}; 
        end if;
        l :={};
        for i from 1 to s do;
                p := 1;
                j := 1;
                while ( j<=r ) do;
                        if ( not evalb(convert(Row(R,j),list)=convert(Row(S,i),list)) ) then
                                j := j+1;
                                p := p+1;
                                if ( j>r ) then
                                        return {};
                                end if;
                        else
                                j := r+1; 
                                l := l union {p};
                        end if;
                od;
        od;
        return l;
end proc: # SinR

end module:
